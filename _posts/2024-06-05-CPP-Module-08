---
title:  "[C++] Module 08"
excerpt: "42seoul inner circle CPP Module 08 진행 후기입니다."

categories:
  - Blog
tags:
  - [42seoul, C++, template, container, algorithm, iterator]

toc: true
toc_sticky: true
 
date: 2024-06-05 11:00:00 +0900
last_modified_at: 2024-06-05 11:00:01 +0900

---

# CPP Module 08 후기

## 프로젝트 목표

Templated containers, iterators, algorithms

STL, 컨테이너와 <algorithm> 적절히 활용하기.

# STL을 학습하기 전 알아야할 C++ 문법

## chapter 1. 연산자_오버로딩

사용자 정의 자료형 클래스에 대해 연산자를 어떻게 동작시킬지 정의하는 `연산자 오버로딩` 이 필요하다.

`연산자 오버로딩` 은 컴파일러와 약속된 함수(operator+, operator[], etc.) 를 이용해 사용자 정의 타입에 연ㅇ산이 가능하도록 제공하는 것이다.

연산자들도 함수의 동작과 동일하게 구성되어있다.

예를들어,

```cpp
class Point
{
	// ...
}

int main()
{
	Point p1;
	Point p2;
	
	p1 + p2; // p1.operator+(p2) 와 동일
}
```

`연산자 오버로딩`은 생각해보면 해당 클래스의 멤버 함수로 오버로딩된 연산자 함수를 동작하는 것이다.

<aside> 💡 const 멤버 함수와 비 const 멤버 함수

const 멤버 함수는 객체의 멤버 변수들의 값을 변경하지 않는다는 것을 보장하는 함수. → 자신의 멤버 값을 변경하지 않는 멤버 함수는 모두 const 멤버로 작성할 것.

</aside>

## 증감 연산자 ++ / —

약간의 특징적인 부분이 있는 연산자 오버로딩으로, 증감 연산자 오버로딩이 존재한다.

전위 후위 연산자 모두 operator++() 멤버 함수를 호출한다. 전위 연산자와 후위 연산자를 구분하기 위해서 후위 연산자는 멤버 함수 호출 시 의미 없는 `더미 정수형 인자 0` 을 전달한다.

```cpp
const Point& operator++()
{
	++x;
	++y;
	return *this;
}

const Point operator++(int)
{
	Point pt(x, y); // return 을 위한 현재값 담을 변수
	++x;
	++y;
	return pt;
}
```

## 전역 함수를 이용한 연산자 오버로딩

앞서 배워온 `연산자 오버로딩` 은 멤버 함수를 이용한 오버로딩이었다. 하지만 예를 들어 이항연산의 왼쪽 객체가 연산자 오버로딩된 객체가 아니라면 당연히 해당 연산자에 대한 처리 방식이 정해지지 않아 연산자 계산이 되지 않는다.

이럴 경우 전역함수를 이용하여 `연산자 오버로딩` 을 진행해야하며, 멤버 함수를 이용하는 경우 자연스럽게 왼쪽 객체가 함수 호출의 주체가 되어 `this` 로 존재했다. 전역함수를 이용한다면 왼, 오른쪽 객체를 연산자의 인자로 각각 들어갈 수 있도록 처리해줘야한다.

**멤버 함수를 이용한 연산자 오버로딩 예시**

```cpp
class Point
{

...
	const Point operator-(const Point& arg) const
	{
		return Point(x - arg.x , y - arg.y);
	}
};
```

**전역 함수를 이용한 연산자 오버로딩 예시**

```cpp
class Point
{

...
	const Point operator-(const Point& argL, const Point& argR) const
	{
		return Point(argL.GetX() - argR.GetX() , argL.GetY() - argR.GetY());
	}
};
```

이처럼 전역 함수를 활용하면 클래스 객체의 `private` 영역에는 접근하지 못하므로, 게터 세터를 이용하여 접근하거나 friend 함수로 선언하여 클래스 내 객체의 모든 영역에 자유롭게 접근할 수 있도록 해준다.

하지만 객체 지향의 의미와 캡슐화를 위해, 게터 세터로 접근하는 것이 올바른 접근 방식이다.

`friend` 함수는 캡슐화를 저해하는 키워드. 편하지만 지양하는 것이 좋은 습관이다.

## STL에 필요한 주요 연산자 오버로딩

### 함수 호출 연산자 () 오버로딩

C++ 에서 Print(10) 은 세 가지로 해석될 수 있다.

- 함수 호출 : Print 가 함수 이름
- 함수 포인터 : Print 가 함수 포인터
- 함수 객체 : Print 가 함수 객체 → 클래스의 객체인데 () 를 사용하여 지정된 멤버 함수를 호출하는 방식

아래 코드와 같이 멤버 함수로 연산자 오버로딩을 통해 함수 객체로서 동작을 정의할 수 있음.

```cpp
struct FuncObject
{
public:
	void operator() (int arg) const
	{
		cout << "int : " << arg << endl;
	}
```

```cpp
int main()
{
	FuncObject print;
	print(10); // 객체 생성 후 호출 ( () 연산자의 암시적 호출)
	print.operator()(10); // 객체 생성 후 () 연산자 명시적 호출
	
	FuncObject()(10); // 임시 객체로 () 연산자 암시적 호출
	FuncObject().operator()(10); // 임시 객체로 () 연산자 명시적 호출
}
```

<aside> 💡 임시 객체

위 코드에서, `FuncObject()` 처럼 클래스 이름으로 임시 객체를 생성할 수 있다. 임시 객체는 그 문장에서 생성되고 그 문장을 벗어나면 소멸됨. 그 문장에서만 임시로 필요한 객체에 사용.

</aside>

## 배열 인덱스 연산자 [] 오버로딩

[ ]연산자는 일반적으로 컨테이너 객체에 사용.

객체가 관리하는 내부 원소에 접근할 때 사용

```cpp
class Point
{
...
public:
	int operator[] (int idx) const
	{
	if (idx == 0)
		return x;
	else if (idx == 1)
		return y;
	else
		throw "이럴수는 없는 거야!";
		
```

## 메모리 접근, 클래스 멤버 접근 연산자 (*, →) 오버로딩

## 타입 변환 연산자 오버로딩


# chapter 2. 함수 포인터란

함수의 주소를 저장하는 포인터 → 함수명

함수 포인터 선언은 사용하고자 하는 함수의 시그니처와 동일하게 출력자료형, 인자 구성 필요

```cpp
// void Print(int n) 의 함수포인터 선언 시,
void (*pf)(int);
pf = Print;

Print(10); // 1. 함수 호출
pf(10);    // 2. 포인터를 이용한 함수 호출
(*pf)(10); // 3. 포인터를 이용한 함수 호출
```

위 세 가지 방법 모두 함수를 호출하는 방법.

2, 3 은 표현법은 다르나 동일하게 함수 포인터를 이용하는 함수 호출방식이다.

## Section 02 함수 포인터 종류

함수 호출에는 세 가지가 존재

- `static` 함수 호출 (정적 함수)
- 객체로 멤버 함수 호출(멤버 함수)
- 객체의 주소로 멤버 함수 호출(멤버 함수)

이에 따라, 함수 포인터 선언과 호출은 세 가지 함수 호출 방식에 따라 차이가 있다.

```cpp
int main()
{
	point pt;
	Point *p = &pt;
	
	Print();    // 정적 함수 호출
	pt.Print(); // 객체로 멤버 함수 호출
	p->Print(); // 주소로 멤버 함수 호출
}
```

### 정적 함수 호출

함수의 시그니처만 알면 쉽게 선언이 가능하다.

정적 함수로는 `전역 함수` , `namespace` 내의 `전역 함수` , `static` 멤버 함수가 존재하며,

이들은 함수 호출 규약이 같아 함수포인터가 같다.

```cpp
int main()
{
	void (*pf)(int); // 정적 함수 포인터 선언
	
	
	Print(10);        // 전역 함수 호출
	A::Print(10);     // 네임스페이스 A의 전역 함수 호출
	Point::Print(10); // Point 클래스의 정적 멤버 함수 호출
	
	pf = Print;
	pf = A::Print;
	pf = Point::Print;
	
	...
}
```

정적 함수는 모두 같은 함수 포인터를 사용.

### 객체와 주소로 멤버 함수 호출

```cpp
int main()
{
	Point pt(2, 3);
	Point *p = &pt;

	void (Point::*pf1)() const; // 멤버 함수 포인터 선언
	pf1 = &Point::Print;
	
	void (Point::*pf2)(int);    // 멤버 함수 포인터 선언
	pf2 = &Point::PrintInt;
	
	(pt.*pf1)(); // 객체로 멤버 함수 포인터 호출
	(pt.*pf2)(10); // 객체로 멤버 함수 포인터 호출
	
	(p->*pf1)();    // 주소로 멤버 함수 포인터 호출
	(p->*pf2)(10);  // 주소로 멤버 함수 포인터 호출
	
	return 0;
}
```

## Section 03 클라이언트 코드와 서버 코드

서버는 클라이언트 정책을 반영하려고 서버 측 코드에서 클라이언트 측 함수를 호출.

→ 이때 서버가 호출하는 클라이언트 함수를 `콜백 함수`라고 함.

STL 의 많은 알고리즘도 콜백을 이용해 클라이언트 정책을 반영한다.

# chapter 3. 함수 객체
() 연산자를 오버로딩한 객체.

`함수객체`는 `함수자, Functor`라고 부른다.

특정 클래스의 인스턴스임에도 함수처럼 `()` 연산자를 통해 함수의 동작을 구현할 수 있다.

```cpp
functor(10, 20) // () 연산자의 암시적 구현
functor.operator() (10, 20) // () 연산자의 명시적 구현
```

### 함수 객체의 장점

- 객체이기에 다른 멤버 변수와 함수를 가질 수 있다.
- 함수 객체의 시그니처가 같아도 객체 타입이 다르면 서로 전혀 다른 타입으로 인식함.
- 함수 객체는 인라인될 수 있어서, 컴파일러가 최적화 할 수 있다.
- 속도도 일반 함수보다 빠르다.

 **inline function** 인라인 함수는 **컴파일 시 호출 지점에 함수 코드를 직접 삽입함**으로써, **함수 호출에 따른 오버헤드를 줄일 수 있습니다.** 따라서, 함수 객체는 인라인될 가능성이 높고, 이는 실행 시간의 최적화를 의미합니다. 컴파일러는 함수 객체의 사용 문맥을 보고 인라인 확장을 결정할 수 있으며, 이는 코드의 실행 속도를 향상시킬 수 있습니다.

이러한 장점을 바탕으로 STL 에서도 함수 객체를 곳곳에서 사용한다.


# chapter 4. 템플릿
## Section 01 함수 템플릿

템플릿 함수를 사용하면, 컴파일러는 클라이언트의 함수 호출 인자 타입을 보고 템플릿 함수의 매개변수 타입을 결정하여 실제 함수인 템플릿 인스턴스 함수를 만듬.

서버 함수는 일반화된 기능만을 제공.

클라이언트 → 함수의 매개변수 타입 결정. 얼마든지 다른 함수들을 만들어낼 수 있다.

```cpp
template<typename T>
void Print(T a, T b)
{
	cout << a << ", " << b << endl;
}
```

일반화된 템플릿이 클라이언트에 의해 자료형 T 가 결정되어 컴파일러에 의해 생성되는 함수를 `템플릿의 인스턴스` 라고 한다.

템플릿 함수 정의의 연산이 가능한 객체, 즉 인터페이스를 지원하는 객체라면 모두 템플릿의 자료형 T가 될 수 있다.

```cpp
/* 명시적 호출이 필요한 경우 */
template<typename T, int size>
void PrintArray(T* arr)
{
	for (int i = 0; i < size; i++)
	{
		cout << arr[i] << endl;
	}
}

int main()
{
	int arr1[5] = {10, 20, 30, 40, 50};
	PrintArray<int, 5>(arr1); // 명시적 호출
	
	double arr2[5] = {1.10, 2.20, 3.30};
	PrintArray<double, 5>(arr2); // 명시적 호출
}
```

함수 인자가 arr1 이라는 정보만으론 템플릿 매개변수 인자를 컴파일러가 추론할 수 없다

따라서 명시적으로 템플릿의 자료형을 명시하여 호출하는 방식으로 함수 템플릿 인스턴스를 생성한다.

변수의 값을 출력하는 `Print()` 를 앞서 만들었던 `class Point` 인스턴스를 템플릿의 인자로 전달하게 될 때 문제가 발생할 수 있는데,

1. 템플릿 연산을 진행할 클래스 내의 연산자 오버로딩이 안되어있는 경우.

→ 연산자 오버로딩을 클래스 내에 정의해준다.

하지만 클래스 자체를 수정할 수 없는 특수한 상황의 경우, 문제를 해결할 수 없다.

→ Point 객체를 받는 특수화된 함수 템플릿을 만든다.

```cpp
// 일반화 함수 템플릿
template <typename T>
void Print(T a)
{
	cout << a << endl;
}

template <>
void Print(Point a)
{
	cout << "Print for point:" << a.Print() << endl;
}
```

이처럼 특수한 경우를 처리할 함수 템플릿을 작성하면 별도로 특수한 경우를 위한 케이스를 별도로 처리할 수 있음

- template 특수화와 일반 전역함수
    
    `template <> void Print(Point a)`는 기본 템플릿 함수 `template <typename T> void Print(T a)`에 대한 특수화입니다. `Point` 타입에 대해 특별히 다른 방식으로 처리하고 싶을 때 템플릿 특수화를 사용합니다. 이 특수화된 버전은 컴파일러에게 `T`가 `Point`일 경우 이 특수화된 버전을 사용하라고 지시합니다.
    
    반면에, 템플릿 특수화 없이 다음과 같이 전역 함수로 선언할 경우:
    
    ```cpp
    void Print(Point a)
    {
        cout << "Print for point:" << a.Print() << endl;
    }
    ```
    
    이는 함수 오버로딩의 예시가 됩니다. 여기서 `Print(Point a)` 함수는 템플릿 버전과 독립적으로 존재하며, `Point` 타입의 인자를 받는 경우 이 함수가 호출됩니다.
    
    그렇다면 왜 굳이 템플릿 특수화를 사용할까요?
    
    1. **명시성**: 템플릿 특수화를 사용함으로써 해당 타입에 대한 처리가 템플릿의 일부임을 명확히 합니다. 이는 코드의 가독성과 유지보수성을 높여줍니다.
    2. **선택의 폭**: 때때로 템플릿 내에서 특정 타입에 대해 전혀 다른 처리를 해야 할 때가 있습니다. 이런 경우 템플릿 특수화를 사용하면 해당 타입에 대한 처리를 템플릿의 일부로 통합할 수 있습니다.
    3. **유연성**: 일반 함수 오버로딩과 템플릿을 함께 사용할 경우, 컴파일러는 오버로딩 해결 규칙에 따라 가장 적절한 함수를 선택합니다. 템플릿 특수화는 이러한 선택 과정에 더 세밀한 제어를 가능하게 합니다.
    
    결론적으로, 템플릿 특수화는 코드의 명시성과 유연성을 높이는 방법입니다. 하지만, 특정 상황에서는 일반 함수 오버로딩이 더 적절할 수도 있습니다. 선택은 구현의 목적과 요구 사항에 따라 달라집니다
    

## Section 02 클래스 템플릿

**클래스 템플릿 :** 클래스를 정의하기 위한 메타 클래스 코드.

템플릿 매개변수 인자를 통해 클라이언트가 클래스에 사용될 타입을 결정할 수 있다.

```cpp
template <typename T>
class Array
{
	...
}

int main()
{
	Array<int> iarr; // int (클라이언트가 T 결정) arr 객체
	Array<double> darr;
	Array<string> sarr;
}
```

템플릿 매개변수도 함수의 매개변수처럼, 디폴트 매개 변수값을 지정할 수 있다.

```cpp
template <typename T=int, int capT=100>
class Array
{
	...
}

int main()
{
	Array<> iarr; // default 매개변수 값 int, 100 사용
	Array<double> darr; // 디폴트 매개변수값 100 사용
	Array<string, 10> sarr; // 디폴트 값 사용 X
}
```

마찬가지로 클래스 템플릿의 특수화가 가능하다.

```cpp
template<typename T>
class ObjInfo
{
	T data;
public:
	void Print()
	{
		cout << data << endl;
	}
};

template <> // T를 string으로 특수화
class ObjInfo<string>
{
	string data;
	
public:
	void Print()
	{
		cout << data << endl; // 기타 출력사항들에 대해 조정 가능
	}
}
```

---
   
## Section 01 STL이란

Standard Template Library. 프로그램에 필요한 자료구조와 알고리즘을 템플릿으로 제공하는 라이브러리.

자료구조와 알고리즘은 반복자를 통해 연결.

- 컨테이너 : 객체를 저장하는 객체. 컬렉션 또는 자료구조라고 한다.
- 반복자 : 컨테이너의 원소를 가리키고 가리키는 원소에 접근하여 다음 원소를 가리키게 하는 기능을 한다.
- 알고리즘 : 정렬, 삭제, 검색, 연산 등을 수행하는 함수 템플릿.
- 함수 객체 : 함수처럼 동작하는 객체로, operator() 연산자를 오버로딩한 객체. 컨테이너와 알고리즘 등에 클라이언트 정책 반영.
- 어댑터 :
- 할당기 :

STL 의 특징은 효율성 / 일반화 프로그램 / 확장성

## Section 02 STL을 한눈에

> 컨테이너

같은 타입을 저장, 관리할 목적으로 만들어진 클래스.

- 표준 시퀀스 컨테이너 : 컨테이너 원소가 자신만의 삽입 위치(순서)를 가지는 컨테이너(vector, deque, list : 선형적)
- 표준 연관 컨테이너 : 저장 원소가 삽입 순서와 다르게 특정 정렬 기준에 의해 자동 정렬되는 컨테이너(set, multiset, map, multimap : 비선형적)

또한, 메모리 저장 방식에 따라서도 종류가 나뉨.

- 배열 기반 컨테이너 : 데이터 여러 개가 하나의 메모리 단위에 저장(vector, deque)
- 노드 기반 컨테이너 : 데이터 하나를 하나의 메모리 단위에 저장(list, set, multiset, map, multimap)

> 반복자

컨테이너에 저장된 원소를 순회하고 접근하는 일반화된 방법 제공.

컨테이너와 알고리즘이 연결되게 하는 인터페이스의 역할.

**반복자의 특징**

- 반복자는 컨테이너 내부의 원소를 가리키고 접근할 수 있어야 한다. (*연산자 제공)
- 반복자는 다음 원소로 이동하고 컨테이너의 모든 원소를 순회할 수 있어야함.

STL에서 컨테이너 원소(객체)의 집합을 순차열(sequence)라고 한다.

순차열 개념은 원소의 순서 있는 집합을 의미한다.순차열은 하나의 시작과 하나의 끝을 가진다. 반복자는 순차열의 한 원소를 가리킨다.

STL의 모든 컨테이너는 자신만의 반복자를 제공함. `begin()` , `end()` 가 순차열의 시작과 끝을 가리키는 반복자를 반환함.

주의할 점은 끝이 실제 원소가 아닌 끝을 표시하는 원소이다. begin과 end를 구간이라하며, 수학에서 표기하는 방법을 사용해 반개 구간을 [begin, end) 처럼 표기한다.

```cpp
vector<int>::iterator iter;
for (iter = v.begin(); iter != v.end(); ++iter)
	cout << *iter << endl;
```

반복자에 증감 연산자로 시퀀스의 앞 뒤로 이동이 가능하며, 역참조를 통해 해당 반복자가 포인팅하는 값을 확인할 수 있다.

반복자는 5가지 범주로 분류된다.

- 입력 반복자 : 현 위치의 원소를 한 번만 읽을 수 있는 반복자
- 출력 반복자 : 현 위치의 원소를 한 번만 쓸 수 있는 반복자
- 순방향 반복자 : 입력, 출력 반복자 기능에 순방향 이동(++) 이 가능한 재할당될 수 있는 반복자
- 양방향 반복자 : 순방향 반복자 기능에 역방향으로 이동(—) 이 가능한 반복자
- 임의 접근 반복자 : 양방향 반복자 기능에 +, -, +=, -=, []연산이 가능한 반복자.

STL의 종류에 따라 제공되는 반복자의 종류가 다를 수 있음!

> 알고리즘

STL 순차열 원소를 조사, 변경, 관리, 처리할 목적으로 알고리즘이라는 구성요소 제공.

알고리즘에는 한 쌍의 반복자([begin, end))를 필요로 하며 알고리즘 대부분은 순방향 반복자를 요구하나 몇몇 알고리즘은 임의 접근 반복자를 요구한다.

> 함수 객체

> 어댑터

> 할당기


--- 

# easyfind

### 문제목표

알고리즘 헤더와 반복자 활용

---

### 풀이과정

08의 경우 `<algorithm>` 헤더와 여러가지 `container` 를 사용해보는 과제였다.

그 중 00번은 int 컨테이너 내의 값을 찾는 템플릿 함수를 만드는 과제였다.

컨테이너를 받으면, 그 컨테이너의 시작을 나타낼 `begin()`, 끝을 나타낼 `end()` 함수를 이용하여 반복자 주소를 얻는다.

그 후 알고리즘 헤더에서 find 함수를 이용하여 값이 존재하는지를 탐색한다.

find 함수는 값을 찾으면 해당 반복자를 리턴하고, 없다면 last 반복자(end() 함수로 얻은 컨테이너 마지막 위치)를 리턴한다.

여기서 `const_iterator` 와 `iterator` 를 구분지어, 각 요소에 적용될 수 있게끔 해주는 것이 필요하다. 

** 사실 `iterator` 만으로도 상수형에 대한 처리가 가능하다. 왜냐하면 `iterator` 자체가 상수형에 대해 `const_iterator`를 반환하도록 처리하기 때문이다. **

두 가지로 오버로딩하여 명시하는 것은 프로그래머에게 좀 더 명확한 처리에 대한 인상을 줄 수 있다.

C++11 표준부터는 `auto` 형을 통해 처리하기 때문에 좀 더 유연한 처리가 가능하다.

```cpp
template <typename T>
typename T::const_iterator easyfind(const T &container, int val)
{
	std::cout << "EASYFIND CONST" << std::endl;
	typename T::const_iterator b_iter = container.begin();
	typename T::const_iterator e_iter = container.end();
	return (std::find(b_iter, e_iter, val));
}

template <typename T>
typename T::iterator easyfind(T &container, int val)
{
	std::cout << "EASYFIND" << std::endl;
	typename T::iterator b_iter = container.begin();
	typename T::iterator e_iter = container.end();
	return (std::find(b_iter, e_iter, val));
}
```

> const 위치에 따른 자료형

`const` 는 여러 위치에 존재할 수 있다. `const` 는 해당 값의 변화를 불가능하게 하여 계속 유지되어야 하는 값에 대해 유용하게 사용된다.

1. `const std::vector<int>`:이 선언은 벡터 자체가 상수임을 의미합니다. 즉, 벡터의 요소를 추가, 제거 또는 수정할 수 없습니다.벡터의 요소들 자체는 상수가 아니므로, 각 요소의 값은 변경할 수 있습니다.
    
    ```cpp
    const std::vector<int> v = {1, 2, 3};
    *// v.push_back(4);  // 오류: const 벡터에 요소를 추가할 수 없음
    // v[0] = 10;       // 오류: const 벡터의 요소를 수정할 수 없음*
    ```
    
2. `std::vector<const int>`:이 선언은 벡터의 요소들이 상수임을 의미합니다. 즉, 벡터의 각 요소의 값을 변경할 수 없습니다.그러나 벡터 자체는 상수가 아니므로 요소를 추가하거나 제거할 수 있습니다.
    
    ```cpp
    std::vector<const int> v = {1, 2, 3};
    *// v.push_back(4);  // 가능: 벡터 자체는 상수가 아님
    // v[0] = 10;       // 오류: 벡터 요소는 상수. 수정할 수 없음*
    ```
    
3. `const std::vector<const int>`:이 선언은 벡터 자체와 벡터의 요소들이 모두 상수임을 의미합니다. 즉, 벡터의 요소를 추가, 제거할 수 없으며, 각 요소의 값도 변경할 수 없습니다.
    
    ```cpp
    const std::vector<const int> v = {1, 2, 3};
    *// v.push_back(4);  // 오류: const 벡터에 요소를 추가할 수 없음
    // v[0] = 10;       // 오류: const 벡터의 요소를 수정할 수 없음*
    ```

---
# Span

## 문제 목표

Span 클래스를 만들고, int 배열을 받아서 각 값들 간 최소 거리와 최대 거리를 찾는다.

---

## 풀이 방법

최대거리는 최대값과 최소값 간의 차이로 구해주면 되고,

최소거리는 배열을 오름차순 정렬시킨 후 바로 왼쪽의 값과 비교하여 최소거리값을 가지는 경우를 리턴하자.

이것들을 알고리즘 헤더에 존재하는 `std::sort`, `std::max_element`, `std::min_element` 를 이용하여 풀이하였다

또한 한번에 여러가지 값을 스팬 클래스 내 배열에 넣을 수 있어야한다.

다양한 컨테이너 타입이 인자로 들어올 수 있고, 그 컨테이너 타입의 반복자를 이용하여, `begin()`, `end()` 까지의 값을 배열에 넣도록 한다.

그 과정 중 array의 사이즈를 넘어서면 `exceedArrayException`을 발생시킨다.

또한 span을 구할 수 없는 요소 갯수 (0개 또는 1개)가 존재한다면 구할수 없다는 exception을 던지도록 하였음.

---
# MutantStack

## 문제목표

STL `stack` 은 `iterator`를 가지지 않는다.

스택이 `iterator`를 가지도록 하는 `MutantStack` 을 만들어보자

---

## 풀이 방법

기본적으로 스택은 `container adaptor` 이다.

이는 컨테이너를 사용자의 편의에 맞추어(adapt) 연결해주는 역할을 하는데,

실제로 스택 자체의 자료구조가 존재하는 것이 아닌, `deque`, `vector` 등을 활용하여 해당 자료구조를 스택의 형태로 알맞게 (iterator, 임의 접근 연산자 등을 캡슐화 …) 만들어 사용한다.

따라서 우리는 `stack` 자료구조를 `MutantStack` 에 상속하고, 없던 `iterator` 를 새로 선언하여 사용할 수 있게끔 한다.

마찬가지로 const_iterator에 대해서도 동작할 수 있도록 `cbegin`, `cend`를 구현해주었다.

`typename` 키워드는 컴파일러가 해당 내용이 자료형이라는 것을 알려주는 키워드로, 사용자가 커스텀한 자료형의 앞에 사용하여 뒤에 나오는 부분이 자료형임을 명시한다.
